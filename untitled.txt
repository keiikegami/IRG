# Gaussian Quadrature
# using QuantEcon package for numerical integration w.r.t the expectation
# 3 nodes Gaussian quadrature of standard lognormal distribution
epss, weights = qnwlogn([num_nodes, num_nodes], [0,0], diagm([0.01, 0.01]));

# collocation function
function vmax(model::IRG, colnodes::Array{Float64, 2}, action::Array{Float64, 2}, coef::Array{Float64, 2})
    xnew = action
    for p in 1:2
        xl, xu = 0.0, colnodes[:, 1]
        for it in 1:maxit
            util, util_der1, util_der2 = u(model, colnodes, action, p), ux(model, colnodes, action, p), uxx(model, colnodes, action, p) 
            Ev, Evx, Evxx = 0.0, 0.0, 0.0
            for k in 1:num_nodes^2
                eps, weight= epss[k, :], weights[k]
                transition, transition_der1, transition_der2 = s(model, action, eps), sx(model, action, eps, p), sxx(model, action, eps, p)
                # evaluation based on the basis functions
                # orderが0以外の時はmatrixで渡すらしいが？
                vn = funeval(coef[:, p], basis, transition)
                vnder1 =  funeval(coef[:, p], basis, transition, Matrix([1 1]))
                vnder2 = funeval(coef[:, p], basis, transition, Matrix([2 2]))
                Ev += weight * vn
                Evx += weight* vnder1.* transition_der1
                Evxx += vnder1.*transition_der2 + vnder2 .* (transition_der1.^2)
            end
            v = util + Ev
            # improvement by Newton method
            delx = -(util_der1 + delta * Evx) ./ (util_der2 + delta*Evxx)
            delx = min(max(delx, xl-x), xu-x)
            x[:, p] = x[:, p] + delx
            if abs(delx) < tol
                break
            end
        end
        xnew[:, p] = x[:, p]
    end
    return v, xnew
end